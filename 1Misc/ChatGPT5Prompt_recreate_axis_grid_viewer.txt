Prompt for ChatGPT 5 — Recreate `make_axis_grid_viewer.py`
===========================================================

Objective
---------
Generate a **single Python file** named `make_axis_grid_viewer.py` that produces the axis-grid HTML viewer described below. The implementation must use only the Python standard library, target Python 3.8+, start with a Unix shebang, and finish with `if __name__ == "__main__": main()`. Output the code only.

CLI Specification
-----------------
Use `argparse` with **optional** flags (no required positionals):

| Option        | Default                                | Purpose |
|---------------|----------------------------------------|---------|
| `--images`    | `<base>/params/images`                 | Directory containing PNGs to visualise. |
| `--workflow`  | `<base>/simple_image1.json`            | ComfyUI workflow JSON (UI export) for node metadata. |
| `-o/--output` | `<images>/0000_axis_grid_viewer.html`  | Output HTML file; ensure parent folders exist. |
| `--base`      | `.`                                    | Base path for resolving relative values. |

Backward-compatible positional arguments are supported in the order `[image_dir workflow output]` to fill any missing options. Reject more than three positional args. Resolve all paths using `Path(...).resolve()` after applying defaults.

Validation & Input Handling
----------------------------
* Confirm the images directory exists and is readable.
* Confirm the workflow JSON exists and parse it into a dictionary keyed by node IDs. Accept shapes:
  * `{ "nodes": { id: node, ... } }`
  * `{ "nodes": [node, ...] }`
  * `[node, ...]`
* Derive readable slider labels in priority order: `title`, then `label`, then `type`, else `"Node <id>"`.

PNG Filename Parsing
--------------------
* Only consider `.png` files.
* Split the stem on `--`. Each segment must look like `<nodeId>-<prop>-<token>` where:
  * `nodeId` is digits only.
  * `prop` matches `[A-Za-z0-9_]+`.
* Strip trailing counters (`_00001`, `_00001_`, etc.) via regex `r"^(.*?)(_+\d+_?)$"` if the first group is non-empty.
* Replace `_` with `.` to get a dotted token; if `float(dotted)` succeeds, treat the value as numeric, storing both the numeric value and display string (with `.`). Otherwise mark it as non-numeric and keep the original token string for key/display.
* Enforce that all PNGs share the same dimension count **and** identical `(nodeId, prop)` signature; error out otherwise.
* For each dimension collect ordered values:
  * If all values are numeric, sort by `(numeric_value, key)`.
  * Otherwise sort lexicographically by key.
* Build:
  * `dim_values`: list of lists containing `{ "k": key, "d": display }`.
  * `lookup`: map of `"k0|k1|...|kN"` → original filename.

HTML Output Requirements
------------------------

* Viewer operates in **lazy-load mode only** — no base64 embedding.
* Generate image URLs **relative** to the output HTML location (use POSIX separators). Do **not** emit `file://` URIs.
* `<title>` and header `<h1>` must both read `ComfyParamVisualizer`.
* Theme toggle stored in `localStorage` under `"viewer_theme"`, honouring the system preference on first visit.
* Empty metadata block (provide `<div class="meta"></div>` with no text).
* Slider UI layout:
  * Each row contains: `[lock checkbox][label (right-aligned)][value bubble + slider][axis select]`.
  * Labels formatted `"<Title>:<nodeId>:<prop>"`.
  * Range width derived from `sliderWidth(n) = min(680, max(140, 140 + (n-2)*36))`.
  * Range inputs share styling with the aligned viewer: 6px track, 24px thumb (26px on hover), accent color from theme.
  * Value bubble shows the current display value.
* Axis select dropdown allows values `"none"`, `"x"`, `"y"`. At most one dimension can own each axis; disabled options should reflect ownership without auto-reassigning other axes.
* Lock checkbox disables its slider even if the axis is released.
* Canvas is replaced by a grid layout:
  * `.grid` uses CSS Grid with 10px gaps, `minmax(256px, 1fr)` columns, and `object-fit: contain; width: 100%; background: #000;` on images.
  * Grid width spans the viewport; horizontal scroll should appear when X has many values.
  * Headers (row/column) use `.hdr` elements; no filenames or “Grid:” text anywhere.
* Modes:
  * **Single**: no X/Y axes; allocate one image cell and use `fitSingleImage()` to clamp height to the viewport (`window.innerHeight - top - 24`, min 100px). Re-run on resize (once per change).
  * **X axis**: headers along top row.
  * **Y axis**: headers along first column.
  * **X + Y axes**: full matrix with headers on top row and first column.
* Flicker-free updates:
  * Maintain `curStruct = { mode, xLen, yLen }` and rebuild the DOM only when structure changes.
  * For every render, iterate existing `<img>` nodes and update `src`/`href` in place. Missing filenames should clear `src` and remove the anchor `href`.

JavaScript Architecture (must match)
------------------------------------

```js
const data = ${meta_json};
const dims = data.dim_values.length;
const curIdx = new Array(dims).fill(0);
const locked = new Array(dims).fill(false);
const axis = new Array(dims).fill("none"); // "none" | "x" | "y"
const slidersRoot = document.getElementById("sliders");
const gridWrap = document.getElementById("gridWrap");
const gridRoot = document.getElementById("grid");
const sliderEls = [];
const lockEls = [];
const axisSelEls = [];
let curStruct = { mode: "", xLen: 0, yLen: 0 };
let imageCells = [];
```

Essential helper behaviour:

* `buildUI()` sets up sliders, lock checkboxes, select elements, updates disabled state, and calls `syncAxisOptions()`.
* `updateDisabledState(i)` disables sliders when locked or when the axis is set to `x` or `y`.
* `syncAxisOptions()` enforces unique axis owners by disabling already-claimed options in other selects without changing their existing selection.
* `keyFrom(idxOverride)` and `fnameFor(idxOverride)` generate lookup keys and filenames using overrides for X/Y indices.
* `ensureStructure(hasX, hasY, xLen, yLen)` rebuilds DOM only when necessary. Use `.hdr` cells for headers and `.cell` divs containing `<a><img></a>` for images.
* `desiredFilenames(...)` returns the list of filenames in row-major order for the current structure.
* `renderGrid()` obtains desired filenames, calls `ensureStructure`, then updates all `<img>` elements (set `decoding = "async"` before assigning `src`).
* `fitSingleImage()` caps the single image’s height to the available space.

CSS Requirements
----------------

* Define light/dark variables identical to the aligned viewer.
* `.container` spans full width (no fixed max width).
* `.grid` uses `gap: 10px`.
* `.hdr` cells style similar to table headers (background tinted, center-aligned).
* `.cell img` must keep aspect ratio and have black background.

Relative Path Generation
------------------------

* Provide a helper `relpath_for_html(target, base)` returning POSIX-style relative paths (replace `\` with `/`).
* Build `image_urls` using that helper for every PNG relative to the output directory.
* JSON metadata should include:
  ```json
  {
    "dim_values": [...],
    "lookup": {...},
    "dim_labels": [...],
    "label_em": <float>,
    "lazy": true,
    "image_urls": {...}
  }
  ```
  (No absolute paths recorded.)

Console Output
--------------

After writing the HTML successfully, print:
1. `Generated HTML: <absolute_output_path>`
2. `Note: Viewer uses lazy-load only. Keep the PNGs in place so the HTML can load them.`

Libraries & Utilities
---------------------

Only import: `argparse`, `json`, `re`, `os`, `sys`, `pathlib.Path`, `string.Template`. Do not add other dependencies.

Error handling should be consistent with the aligned viewer: print errors to `stderr` and exit with status 1 if inputs are invalid.

Deliverable
-----------
Return only the Python code implementing these requirements. No markdown or commentary should appear after the code block.
