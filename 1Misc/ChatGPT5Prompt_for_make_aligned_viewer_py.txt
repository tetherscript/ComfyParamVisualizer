Prompt for ChatGPT 5 â€” Recreate make_aligned_viewer.py
======================================================

Goal
----
Produce a single stdlib-only Python 3 script named make_aligned_viewer.py that generates the aligned image/video viewer HTML exactly as documented below. Target Python 3.8+, include a Unix shebang, and end with:
  if __name__ == "__main__":
      main()
Return only the code.

CLI
---
Use argparse with optional flags only:
- --images  default: <base>/params/images  (directory with poster PNGs and optional MP4s)
- --workflow default: <base>/simple_image1.json (ComfyUI workflow JSON for node titles)
- -o/--output default: <images>/0000_aligned_viewer.html
- --base default: . (base directory used to resolve relative paths)

Accept legacy positional arguments [image_dir workflow output] in order to fill missing options. Reject more than three. Resolve all paths with Path(...).resolve(). Ensure the images directory exists and workflow JSON is readable; otherwise exit with a clear error message (status 1).

Workflow titles
---------------
Parse the workflow JSON which may be one of: {"nodes": {...}}, {"nodes": [...]}, or a bare list. Create a dict id->node. The display title for a node id is chosen with priority: title, then label, then type, else "Node <id>".

Filename parsing and keying
---------------------------
Both .png (posters) and .mp4 (videos) share the same filename schema. Filenames consist of segments separated by "--". Each segment is:
  <nodeId>-<prop>-<valueToken>
- nodeId is decimal digits
- prop matches [A-Za-z0-9_]+
- valueToken may contain underscores

Strip trailing counters like _00001 or _00001_ using regex r"^(.*?)(_+\d+_?)$" if group 1 is non-empty. After stripping, form a dotted token by replacing '_' with '.'. If float(dotted) succeeds, it is numeric; store the numeric value and display string using the dotted form. Otherwise treat as non-numeric and use the raw stripped token as both key and display.

Dimension set and ordering (from PNGs)
--------------------------------------
Only PNGs define the available values/dimensions. Enforce that all posters share the same number of segments and identical (nodeId, prop) signature. Error out if mismatched. For each dimension, collect values and order them:
- If all values are numeric: sort by (numeric_value, key)
- Otherwise: sort lexicographically by key

Build these structures:
- dim_values: per-dimension ordered list of {"k": key, "d": display}
- poster_lookup: map "k0|k1|...|kN" -> poster filename (.png)
- video_lookup: map "k0|k1|...|kN" -> video filename (.mp4) only for keys that have a video (omit otherwise)

HTML meta payload
-----------------
Emit a meta JSON object with exactly these fields (no absolute paths):
- dim_values
- poster_lookup
- video_lookup
- dim_labels: for each dimension "<NodeTitle>:<nodeId>:<prop>"
- label_em: a float sizing the label column (compute as in code: based on max label length, clamped 8..60 em)
- lazy: true
- poster_urls: { poster filename -> POSIX-style relative URL from output dir }
- video_urls: { video filename -> POSIX-style relative URL from output dir }

HTML/CSS/JS layout
------------------
- Title and page header must be "ComfyParamVisualizer".
- Theme toggle button stores preference in localStorage under "viewer_theme" and respects system dark mode on first load.
- Container: max-width 980px; centered with light padding.
- Slider rows: [lock checkbox][right-aligned label][value bubble + range input]. Slider width uses sliderWidth(n)=min(680,max(140,140+(n-2)*36)). Range styling: 6px track; 24px thumb (26px hover); accent color from CSS variables.
- Filename area under sliders shows a link for the current media.
- Image area: a centered <canvas> draws the current poster.
- No base64 images: lazy load by URL when needed.

Interactivity and behavior
--------------------------
- 64-image LRU cache for posters (Map-based LRU sufficient).
- On load, pick any poster (e.g., first value of poster_lookup) to probe natural size and set canvas size. Fallback to 512x512 if probe fails.
- Scaling rules for the canvas draw:
  - Never upscale above natural size
  - Fit inside viewport: available width = window.innerWidth - 32px; available height = window.innerHeight - distance to bottom - 16px
  - Recompute on window resize and redraw current poster
- updateImage():
  - Build key from slider indices; stop/remove active video if any
  - Look up poster filename via poster_lookup; load from cache or network; draw to canvas; set filename link to poster URL
  - Set a boolean hasVideoCurrent if the key exists in video_lookup
- Context menu (right-click) on the canvas opens the current poster in a new tab (window.open with noopener,noreferrer)
- Click behavior (no on-canvas overlay):
  - If hasVideoCurrent is true:
    - Click plays video inline: create <video controls autoplay playsInline>, set poster to current poster URL, set src to video URL, size the element to the current canvas pixel dimensions, hide the canvas, and append the video element in its place
    - Shift+click opens the video URL in a new tab instead of inline playback
    - While playing, the filename link points to the video; when the video ends or sliders change, remove the video, show the canvas again, and restore the filename link to the poster
  - If no video: clicks do nothing special (existing filename link and context menu remain)

Implementation constraints
--------------------------
- Stdlib only: argparse, json, re, os, sys, pathlib.Path, string.Template
- Use string.Template to embed meta_json and label_em; produce POSIX relative paths with relpath_for_html()
- Ensure output parent directory exists; on success print:
  "Generated HTML: <abs_output_path>"
  "Note: Viewer uses lazy-load only. Keep the PNGs in place so the HTML can load them."
- On any validation error: print a descriptive message and exit(1)

Must-match behaviors
--------------------
1) CLI defaults and legacy positional handling as specified
2) PNGs define dimensions; MP4s are optional and keyed to the same parsed key (trailing counters ignored)
3) JSON meta fields: poster_lookup, poster_urls, video_lookup, video_urls (when present)
4) Canvas scales-to-fit without upscaling; redraws on resize
5) Right-click opens poster; click plays inline when available; Shift+click opens video in new tab
6) Title/header is exactly ComfyParamVisualizer; all URLs are relative

