Prompt for ChatGPT 5 — Recreate `make_aligned_viewer.py`
=========================================================

Goal
----
Produce a **single stdlib-only Python 3 script** named `make_aligned_viewer.py` that generates the aligned image viewer HTML exactly as documented below. The script must target Python 3.8+, include a Unix shebang, and end with `if __name__ == "__main__": main()`. Output only the code.

Command-Line Interface
----------------------
Use `argparse` with optional flags only:

| Option        | Default                       | Description |
|---------------|-------------------------------|-------------|
| `--images`    | `<base>/params/images`        | Root folder that contains the PNG set. |
| `--workflow`  | `<base>/simple_image1.json`   | ComfyUI workflow JSON exported from the UI (node metadata). |
| `-o/--output` | `<images>/0000_aligned_viewer.html` | Destination HTML file. Create parent dirs as needed. |
| `--base`      | `.`                           | Base directory used to resolve relative paths for the above. |

All options accept relative paths (resolved against `base`). Emit helpful errors (exit with status 1) when directories/files do not exist or are invalid.

Accept **legacy positional arguments** for backward compatibility: `[image_dir workflow output]` in that exact order. If any of these positional arguments are provided, they fill the corresponding missing option values. Reject extra positional arguments beyond three.

Input Validation
----------------

* Resolve every supplied path via `Path(...).resolve()` before use.
* `--images` must point to an existing directory.
* `--workflow` must be a readable JSON file that contains either:
  * `{ "nodes": { id: node, ... } }`, or
  * `{ "nodes": [node, ...] }`, or
  * `[node, ...]`
* When multiple shapes are possible, always end with a dictionary keyed by node IDs (integers) to node objects. Select node labels by priority: `title`, then `label`, then `type`, else `"Node <id>"`.

PNG File Requirements
---------------------

* Consider only files with `.png` extension (case-sensitive is fine).
* Filenames encode dimensions using `--` as a separator. Each segment must match `<nodeId>-<prop>-<valueToken>`, where:
  * `nodeId` is decimal digits.
  * `prop` matches `[A-Za-z0-9_]+`.
  * `valueToken` may contain underscores.
* Strip trailing counters such as `_00001` or `_00001_` via regex `r"^(.*?)(_+\d+_?)$"` if group 1 is non-empty.
* After stripping, replace `_` with `.` to create a dotted representation. If it parses as `float`, treat it as numeric (store both numeric value and display string with the decimal point). Otherwise treat as non-numeric and use the original token for both key and display.
* All images must share the same dimension count and identical `(nodeId, prop)` signature. If not, exit with an error.
* Sort dimension values: numeric dimensions by `(numeric_value, key)`; non-numeric lexicographically. Build:
  * `dim_values`: ordered list per dimension of `{ "k": key, "d": display }`.
  * `lookup`: map `"k0|k1|...|kN"` → `filename` (with extension).

HTML/JS Output Requirements
---------------------------

* Always generate **lazy-load** HTML—never embed base64 images.
* Generate relative URLs: compute `image_urls` as paths from the output directory to each PNG (POSIX separators). Do **not** use `file://`.
* The HTML `<title>` and header `<h1>` must read **"ComfyParamVisualizer"**.
* Theme toggle (`Theme` button) persists in `localStorage` under key `"viewer_theme"`. Respect system preferences on first load.
* UI layout:
  * Container width max 980px, centered with modest padding.
  * Each dimension renders a slider row: `[lock checkbox][label right-aligned][value bubble + range input]`.
  * Slider labels use the format `"Title:nodeId:property"`.
  * Value bubble shows the current display value (`dim_values[i][index]["d"]`).
  * Slider width scales with option count: `sliderWidth(n) = min(680, max(140, 140+(n-2)*36))`.
  * Range inputs:
    - Base width 240px, track height 6px, accent color from CSS variable.
    - Thumb is a 24px circle (26px on hover) to improve mouse targeting.
  * Include a filename section under the sliders showing the current PNG as a clickable link.
* Viewer canvas renders the image; contextmenu on canvas should open the current PNG in a new tab (`window.open`) without altering the page state.
* Maintain a 64-image LRU cache on the client to speed up switching.
* Image scaling:
  - Never upscale above 100% of the image's natural size.
  - When the image would overflow the viewport, scale it down to fit without requiring browser scrolling.
  - Leave a 16px margin on the left, right, and bottom sides of the image area.
  - Recompute scale on window resize.

* JavaScript flow:
  * Preload nodes/dimensions from `meta_json`.
  * Load one sample image to set canvas dimensions; fall back to 512×512 if loading fails.
  * Build sliders dynamically with lock checkboxes (disabled slider when locked).
  * Track the current index array (`curIdx`) and locked state array (`locked`).
  * `updateImage()` should change the canvas and filename link only when the actual filename changes; reuse cached Image instances when possible.
  * Right-click on the canvas opens `currentUrl` in a new tab (if available).

* CSS & Styling:
  * Use CSS variables for theme colors (light/dark); ensure all backgrounds, borders, and text respect them.
  * Metadata row (`.meta`) remains but is empty (no absolute path text).
  * Increase slider thumb size as specified for better usability.

Implementation Constraints
--------------------------

* Import only: `argparse`, `json`, `re`, `os`, `sys`, `uuid` (if needed, though current script doesn’t), `pathlib.Path`, `string.Template`.
* Use `string.Template` for HTML—protect braces in JS/CSS by doubling or using `$` placeholders properly.
* When writing the HTML:
  * Ensure parent directories for `--output` exist (`mkdir(parents=True, exist_ok=True)`).
  * After successful write, print:
    1. `Generated HTML: <absolute_output_path>`
    2. `Note: Viewer uses lazy-load only. Keep the PNGs in place so the HTML can load them.`
* On any validation or runtime error, print a descriptive message to `stderr` and exit with status 1.

Summary of Must-Match Behaviors
-------------------------------

1. CLI defaults (`--images`, `--workflow`, `--output`, `--base`) must mirror the table above.
2. Legacy positional arguments are honored exactly once, in order, and capped at three entries.
3. All image links inside the HTML are relative to the output file’s directory.
4. The header/title show “ComfyParamVisualizer.”
5. Slider thumb styling uses 24 px base / 26 px hover dimensions.
6. The generated HTML contains no absolute host paths.
7. The script is stdlib-only and structurally mirrors the functions outlined (`parse_args`, `strip_counter`, `parse_dimension_segment`, `parse_filename`, `load_node_titles`, `relpath_for_html`, `main`).

Deliverable
-----------
Return only the Python source code for `make_aligned_viewer.py`. No additional commentary or markdown is permitted after the code block.
